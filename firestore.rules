rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {

      match /uploads/{uploadID}{
        allow read;
      }

      match /users/{userID} {
        allow read;
        allow write;
      }

      match /usernames/{username} {
        allow read;
        allow write;
      }

      match /users/{userID}/uploads/{uploadID} {
        allow read;
        allow create: if canUpload(userID);
      }

        match /users/{userID}/uploads/{uploadID}/likes/{id} {
        allow read;
        allow create: if canLike(userID, uploadID);
        allow delete: if request.auth.uid == resource.data.uid;
      }
      
        match /users/{userID}/uploads/{uploadID}/dislikes/{id} {
        allow read;
        allow create: if canDislike(userID, uploadID);
        allow delete: if request.auth.uid == resource.data.uid;
      }

      match /users/{userID}/uploads/{uploadID} {
        allow read;
        allow update: if validViewUpdate()
      }
      
    }

    function isValidUser(userID) {
      let isOwner = request.auth.uid == userID;
      let username = request.resource.data.username;
      let createdValidUsername = existsAfter(/databases/$(database)/documents/usernames/$(username));
      let valid_fields = hasAll(["username", "photoURL"]);

      return isOwner && username && createdValidUsername && valid_fields;
    }

    function isValidUsername(username) {
			let isOwner = request.auth.uid == request.resource.data.uid;
      let isValidLength = username.size() >= 3 && username.size() <= 15;
      let isValidUserDoc = getAfter(/databases/$(database)/documents/users/$(request.auth.uid)).data.username == username;
      
      return isOwner && isValidLength && isValidUserDoc && hasAll(["uid"]);     
    }

    function canUpload(userID){
      let isOwner = request.auth.uid == userID;
      let isAuthor = request.resource.data.author == userID;
      let valid_fields = hasAll(["author", "createdAt", "description", "id", "thumbnailURL", "title", "videoURL", "views"]);
      return isOwner && isAuthor && valid_fields
    }

    function canLike(userID, uploadID) {
      let isNotOwner = request.auth.uid != userID;
      let hasNotDisliked = !existsAfter(/databases/$(database)/documents/users/$(userID)/uploads/$(uploadID)/dislikes/$(request.auth.uid));
      let valid_fields = hasAll(["uid"]);
      let valid_id = request.auth.uid == request.resource.data.uid;

      return hasNotDisliked && valid_fields && valid_id && isNotOwner;
    }
    
    function canDislike(userID, uploadID) {
      let isNotOwner = request.auth.uid != userID;
      let hasNotLiked = !existsAfter(/databases/$(database)/documents/users/$(userID)/uploads/$(uploadID)/likes/$(request.auth.uid));
      let valid_fields = hasAll(["uid"]);
      let valid_id = request.auth.uid == request.resource.data.uid;

      return hasNotLiked && valid_fields && valid_id && isNotOwner;
    }

    function validViewUpdate() {
      let valid_fields = onlyEditFields(['views']);
      let correct_inc = request.resource.data.views == resource.data.views + 1;
      return valid_fields && correct_inc
    }

    function hasAll(fields) {
      return request.resource.data.keys().hasAll(fields) && hasOnly(fields);
    }

    function hasOnly(fields){
      return request.resource.data.keys().hasOnly(fields);
    }

    function onlyEditFields(allowedFields) {
      let editedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return editedKeys.hasOnly(allowedFields);
    }
  }
}